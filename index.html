<title>exstitch</title>

<script type="importmap">
  {
    "imports": {
      "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
    }
  }
</script>

<div id="app">
  <h1>Debug Output</h1>
  n_y: {{ n_y }} <br>
  n_x: {{ n_x }} <br>
  cell_height: {{ cell_height }} <br>
  cell_width: {{ cell_width }} <br>
  height: {{ height }} <br>
  width: {{ width }} <br>
  palette: {{ palette }} <br>
  mouse: {{mouse}} <br>
  mouse_pos_idx: {{mouse_pos_idx}} <br>

  <h1>Canvas</h1>
  <canvas :height="height" :width="width" @mousemove="mousemove" id="main-canvas"></canvas>

  <h1>Palette</h1>
  <div>
    <div v-for="color in palette">
      <input type="color" v-model="color.value">
    </div>
  </div>

  <h1>Config</h1>
  n_y: <input v-model="n_y" type="number" step="1" min="0"><br>
  n_x: <input v-model="n_x" type="number" step="1" min="0"><br>
  cell_height: <input v-model="cell_height" type="number" step="1" min="0"><br>
  cell_width: <input v-model="cell_width" type="number" step="1" min="0"><br>
</div>

<script type="module">
  import { createApp } from 'vue'

  createApp({
    mounted() {
      // Cells initialization
      this.cells = []
      for (let idx = 0; idx < this.n_y * this.n_x; idx++) {
        let x = idx % this.n_x * this.cell_width;
        let y = Math.floor(idx / this.n_x) * this.cell_height;
        let color = "";
        this.cells.push({ color: color, x: x, y: y })
      }

      // Palette initialization
      this.palette.push({ value: "#ff0000" });
      this.palette.push({ value: "#00ff00" });
      this.palette.push({ value: "#0000ff" });

      //  Canvas initialization
      this.canvas_dom = document.getElementById("main-canvas");
      this.canvas_ctx = this.canvas_dom.getContext("2d");
      this.draw_cell_all();
    },
    data() {
      return {
        n_y: 64,
        n_x: 64,
        cell_height: 8,
        cell_width: 8,
        cells: [],
        palette: [],
        mouse: {
          x: 0,
          y: 0,
        },
        canvas_dom: undefined,
        canvas_ctx: undefined,
        show_grid: true,
      }
    },
    computed: {
      height() {
        return this.n_y * this.cell_height;
      },
      width() {
        return this.n_x * this.cell_width;
      },
      mouse_pos_idx() {
        let x_idx = Math.floor(this.mouse.x / this.cell_width);
        let y_idx = Math.floor(this.mouse.y / this.cell_height);

        return y_idx * this.n_x + x_idx;
      },
    },
    methods: {
      mousemove(e) {
        var rect = e.target.getBoundingClientRect();
        // TODO: Flooring and maxing is workaround.
        this.mouse.x = Math.floor(e.clientX - rect.left);
        this.mouse.y = Math.floor(Math.max(e.clientY - rect.top, 0));
      },
      draw_cell(cell, show_grid, highlighted = false) {
        let ctx = this.canvas_ctx;

        // Clear cell
        {
          ctx.fillStyle = "white";
          ctx.fillRect(cell.x, cell.y, this.cell_width, this.cell_height);
        }

        // Draw cloth
        // {
        //   let gap = 2;
        //   ctx.fillStyle = "ivory";
        //   ctx.fillRect(cell.x + gap, cell.y, this.cell_width - 2 * gap, this.cell_height);
        //   ctx.fillRect(cell.x, cell.y + gap, this.cell_width, this.cell_height - 2 * gap);
        // }

        // Fill color
        if (cell.color != "") {
          ctx.rect(cell.x, cell.y, this.cell_width, this.cell_height);
          ctx.fillStyle = cell.color;
          ctx.fill();
        }

        // Grid
        if (show_grid) {
          let line_width = 1;
          ctx.beginPath();
          ctx.lineWidth = line_width;
          ctx.strokeStyle = "lightgray";
          ctx.rect(cell.x + line_width / 2, cell.y + line_width / 2, this.cell_width - line_width, this.cell_height - line_width);
          ctx.stroke();
        }

        // Outline highlight
        if (highlighted) {
          let line_width = 1;
          ctx.beginPath();
          ctx.lineWidth = line_width;
          ctx.strokeStyle = "red";
          ctx.rect(cell.x + line_width / 2, cell.y + line_width / 2, this.cell_width - line_width, this.cell_height - line_width);
          ctx.stroke();
        }
      },
      draw_cell_all() {
        for (let idx = 0; idx < this.n_y * this.n_x; idx++) {
          this.draw_cell(this.cells[idx], this.show_grid)
        }
      },
    },
    watch: {
      mouse_pos_idx(new_val, old_val) {
        this.draw_cell(this.cells[new_val], this.show_grid, true);
        this.draw_cell(this.cells[old_val], this.show_grid, false);
      }
    }
  }).mount('#app')
</script>